<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="src/github-pandoc.css" type="text/css" />
</head>
<body>
<h1 id="lora-protocol">LoRa protocol</h1>
<ul>
<li><a href="LoRaProtocol_documentation.html">LoRa</a></li>
<li><a href="Registrazione.html">Registrazione</a></li>
<li><a href="SerialProtocol.html">Seriale</a></li>
</ul>
<p>Questo protocollo è stato creato per l'utilizzo all'interno di una rete LoRa per la comunicazione wireless tra vari dispositivi</p>
<p>Legenda:</p>
<p>I bit vengono considerati ordinati da sinistra a desta in questo modo:</p>
<table>
<thead>
<tr class="header">
<th>1BYTE</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>Il bit 1 è il più significativo (128)</p>
<hr />
<h2 id="descrizione-del-formato-del-pacchetto">Descrizione del formato del pacchetto</h2>
<p>Il pacchetto è diviso in due parti:</p>
<ul>
<li>Header</li>
<li>Payload</li>
</ul>
<p>L'insieme di queste due parti non può superare i 255 byte.</p>
<h3 id="header">Header</h3>
<p>L'header di un pacchetto LoRa è formato da 11 bytes:</p>
<ul>
<li>4 bytes per l'indirizzo del destinatario</li>
<li>4 bytes per l'indirizzo del mittente</li>
<li>1 byte per il tipo di messaggio</li>
<li>1 byte per il numero di sequenza del pacchetto</li>
<li>1 byte per la lunghezza del payload (par avere un leggero controllo d'integrità, considerare l'uso di un crc16 o 32)</li>
</ul>
<p>Descrizione del byte riservato per il tipo di messaggio:</p>
<ul>
<li>bit 1 : indica se il pacchetto contiene un messaggio (bit settato a 1) oppure se è un messaggio ACK (bit settato a 0)</li>
<li>bit 2-6: riservati per usi futuri per indicare il tipo di messaggio (status report, comando, keep alive...) **</li>
<li>bit 7-8: indicano il livello di QoS utilizzato: 0 = no ACK, 1 = ACK, 2 = ACK a tre passi</li>
</ul>
<p>**[Nota]: Valori di tipologia del pacchetto:</p>
<ul>
<li>1: <a href="Registrazione.html">Pacchetti di registrazione</a></li>
</ul>
<h3 id="payload">Payload</h3>
<p>Il payload del masseaggio varia a seconda del tipo di pacchetto scelto.</p>
<p>Per i pacchetti ACK il payload è vuoto ed il byte di lunghezza del payload deve essere settato a 0</p>
<p>I pacchetti non ack avranno un payload diverso a seconda del tipo spacificato dei bit 2-6 del campo tipo (Il loro formato non è ancora stato deciso)</p>
<hr />
<h2 id="documentazione-tecnica-della-libreria-loraprotocol">Documentazione tecnica della libreria LoRaProtocol</h2>
<p><code>class Packet</code>: rappresenta un pacchetto spedito od inviato tramite LoRa.<br />
Attributi:</p>
<ul>
<li><code>dest</code> : il destinatario del pacchetto</li>
<li><code>sender</code> : il mittente del pacchetto</li>
<li><code>type</code> : il tipo di pacchetto</li>
<li><code>packetLenght</code>: la lunghezza del payload</li>
<li><code>packetNumber</code> : il numero di sequenza del pacchetto</li>
<li><code>body</code> : il payload del pacchetto</li>
</ul>
<p>Metodi:</p>
<ul>
<li><code>isAck()</code> : controlla se il pacchetto è un'ack</li>
<li><code>requestsAck()</code>: controlla se il pacchetto richiede un ack in risposta</li>
<li><code>isUninitialized()</code>: controlla se il pacchetto è stato inizializzato o meno</li>
</ul>
<hr />
<p><code>struct Helpers</code>: medodi helpers per scrivere interi a più bytes nel flusso in uscita e leggerli dal flusso in entrata</p>
<p>Unico metodo da utilizzare al di fuori della libreria:</p>
<ul>
<li><code>printResponseMessage(int response_code)</code> : stampa la stringa equivalente al risultato di un'operazione di tipo <code>sendPacket</code></li>
</ul>
<p>Utilizzo:</p>
<pre><code>int result = sendPacket(myPacket);
Helpers::printResponseMessage(result);</code></pre>
<hr />
<p>Costruttori di pacchetti predefiniti:</p>
<p><code>static Packet MessagePacket(uint32_t dest, uint32_t sender, char body[], uint8_t packetLenght)</code></p>
<p>Crea un pacchetto di tipo messaggio rivolto al mittente <code>dest</code> dal dispositivo <code>sender</code> contenente il messaggio <code>body</code>. Il valore di packetLenght deve essere al massimo della lunghezza del campo body</p>
<p><code>static Packet MessageAckPacket(uint32_t dest, uint32_t sender, char body[], uint8_t packetLenght)</code></p>
<p>Uguale al metodo soprastante, ma richiede un'ACK in risposta, riprovando ad inviare tre volte il pacchetto in caso di mancata ricezione</p>
<p><code>static Packet AckPacket(uint32_t dest, uint32_t sender, uint8_t reponsePacketNumber)</code></p>
<p>Crea un pacchetto di ACK di risposta, utilizzato all'interno della libreria e non deve essere utilizzato all'interno dello sketch</p>
<p><em>Per tipi di pacchetti aggiuntivi consultare le sezioni relative alle singole tipologie specifiche di messaggio</em></p>
<hr />
<p><code>void initLoRa(int _myAddress, int csPin, int resetPin, int irqPin)</code> : inizializza la scheda LoRa sui pin dati ed imposta il proprio indirizzo per lo scambio di messaggio</p>
<p><code>int sendPacket(Packet packet)</code> : invia un pacchetto e ritorna: 1 se il pacchetto è stato inviato, 0 altrimenti</p>
<p><code>void activateReceiveMode()</code> : mette la scheda in modalità ascolto (chiamato automaticamente ogni volta che serve dalla libreria, utilizzarlo solo se si richiama esplicitamente <code>LoRa.idle()</code>)</p>
<p><code>void receivePacket(int packetSize)</code> : chiamata automaticamente quando un pacchetto viene ricevuto in modalità ascolto, risponde con un ack se necessario</p>
<h3 id="importante">Importante!</h3>
<p><code>void subscribeToReceivePacketEvent(functionCall function)</code>: passa alla libreria la funzione da richiamare automaticamente ogni volta che si riceve un pacchetto</p>
<p>Utilizzo:</p>
<p>creare un metodo del tipo:</p>
<p><code>void receivedPacketHandler(Packet myPacket)</code></p>
<p>nel setup dello sketch utilizzare la funzione nel seguente modo:</p>
<p><code>subscribeToReceivePacketEvent(receivedPacketHandler);</code></p>
<p>La funzione receivedPacketHandler sarà automaticamente richiamata ogni volta che si riceve un pacchetto</p>
<p>!!! Attenzione !!! Non è possibile chiamare la funzione <code>sendPacket</code> all'interno della funzione fornita se i messaggi richiedono ack ed è ALTAMENTE SCONSIGLIATO in ogni altro caso</p>
</body>
</html>
